## Proposal: Live rendering

The following describes a proposal to implement a "live reloading" feature for Portal. This feature allows users to edit `Portal.View` objects using Xcode and then watch changes be reflected on a running application in real time.

## Live reload flow

1. Portal user returns command `.presentPlayground` in application's `update` function.
2. CommandExecutor interprets `.presentPlayground` and calls `PortalUIApplication.presentPlayground()`.
3. `PortalUIApplication.presentPlayground()` creates a new window and adds as root controller an instance of `LiveReloadViewController` which connects to an instance of `PortalLiveReloadServer` as a rendering client.
4. `PortalLiveReloadServer` also watches changes of a file that must contain a class conforming to `PortalPlayground` protocol.
5. Every time such file changes the server compiles the file by building a Swift Package Manager compatible project that creates a command line tool called `pcs` (Portal Component Serializer).
6. `pcs` is run which causes it to execute the `render` functions of the type that conforms to `PortalPlayground`, serializes the returned view, connects to a running instance of a `PortalLiveReloadServer` and sends the serialized component.
7. `PortalLiveReloadServer`, which depends on a macOS compatible version of Portal, is responsible for
    * Maintaining a reference to the current displayed component
    * Accept render request from `pcs` clients and then generate change sets between current displayed component and received component
    * Store received component as the new current displayed component
    * Broadcast change set to any connected rendering client
8. When a change set is broadcasted by `PortalLiveReloadServer`, all listening `LiveReloadViewController` clients render such change set into their respective container views.

### Observations

#### Using host application's types

Most probably in a real world scenario, Portal users would want to be able to access their application view code inside the `render` method of the type conforming to `PortalPlayground`. In order to do so, users must create a macOS compatible version of their application's core framework which should contain any code that needs to be shared with the playground. This has the implication of making such shared code cross compatible (at least between iOS and macOS) and requires a macOS compatible version of Portal.

#### Portal live reload server

The server app could use the [BlueSocket](https://github.com/IBM-Swift/BlueSocket) library to implement a TCP server which listens on one port to accepts rendering client connections and on another one where it processes (serially) component render requests.


#### Portal component serializer

This tool's main file is autogenerated and it should do something similar to

```swift
import Portal

let playground: PortalPlayground = MyApplicationPlayground()
let component = playground.render()
let liveReloadClient = LiveReloadClient(host: .localhost, port: 4041)
do {
  try liveReloadClient.send(component: component)
catch {
  // TODO handle error
}
```


```swift
enum PlaygroundMessage {

    case .closePlayground

}

protocol PortalPlayground {

    init()

    func render() -> Component<PlaygroundMessage>

}
```

#### Portal live reload view controller

```swift
public final class LiveReloadViewController: PortalViewController {

  let client: LiveReloadClient
  var connection: LiveReloadConnection? = .none

  init(client: PortalLiveReloadClient) {
    client = client
    super.init()
  }

  deinit {
    connection?.close()
    connection = .none
  }

  override public func viewDidLoad() {
    do {
      connection = try client.connect { [unowned self] event in
        switch event {

        case .render(changeSet: ComponentChangeSet<PlaygroundMessage>):
          self.apply(changeSet: changeSet)

        case .connectionTerminated(let maybeError):
          print("Connection terminated!")
          self.connection = .none

        }
      }
    } catch {
      // TODO handle error
    }
  }

}
```
